# 相关笔记

## CPU模式

cpu有3个模式
1:实模式
是cpu启动的时候的模式
这时候就相当于一个速度超快的8086
不能使用多线程
不能实现权限分级
还不能访问20位以上地址线,也就是说只能访问1m内存(!!!)
2:保护模式
操作系统接管cpu后.
会使cpu进入保护模式.
这时候可以发挥80x86的所有威力..
包括权限分级.内存分页.等等等等各种功能
3:虚拟8086模式,也就是为了兼容以前16程序的.没什么好说的
实模式下
跟8086的编程方式非常相似
除了寄存器都是32位的以外

## 段描述表

考虑到各种属性和需要设置的操作，32位保护模 式下对一个内存段的描述需要8个字节，其称之为段描述符(Segment Descriptor)。段 描述符分为数据段描述符、指令段描述符和系统段描述符三种。

![1F22415A334C9EB7470FEABA2CB96EB2](/Users/hq/Documents/1F22415A334C9EB7470FEABA2CB96EB2.png)

> 我们之前简单的阐述了分段，事实上 现代操作系统几乎不再使用分段而是绕过分段技术直接使用了分页。其实分段和分页没什 么必然联系。只不过Intel从8086开始，其制造的CPU就以段地址+偏移地址的方式来访问 内存。后来要兼容以前的CPU，Intel不得不一直保留着这个传统。分段可以说是Intel的 CPU一直保持着的一种机制，而分页只是保护模式下的一种内存管理策略。不过想开启分页 机制，CPU就必须工作在保护模式，而工作在保护模式时候可以不开启分页。所以事实上分 段是必须的，而分页是可选的。

### 为什么需要分段

8086cpu地址总线有20根，但是寄存器却只有16位，为了能够用完所有的20根地址总线，所以采用了分段访问内存的方式。

## 内存屏障(Memory barrier)

内存屏障，也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。

Memory barrier 能够让 CPU 或编译器在内存访问上有序。

一个 Memory barrier 之前的内存访问操作必定先于其之后的完成。

> ref: c volatile关键字和java volatile
>
> 可以理解为语言级别的内存屏障，即编译器屏障，禁止指令重排序穿越内存屏障；对缓存的修改要立即写入内存；写操作会导致其他cpu核心中的缓存失效。

1. lfence，是一种Load Barrier 读屏障。在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据

2. sfence, 是一种Store Barrier 写屏障。在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存

3. mfence, 是一种全能型的屏障，具备ifence和sfence的能力

4. Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。它后面可以跟ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG等指令。

## 中断处理

### 中断描述表

## 分页

由于操作系统管理物理内存，它应知道物理内存的分配细节：哪些帧已分配，哪些帧空着，总共有多少帧，等等。这些信息通常保存在称为帧表的[数据结构](http://c.biancheng.net/data_structure/)中。在帧表中，每个条目对应着一个帧，以表示该帧是空闲还是已占用；如果占用，是被哪个（或哪些）进程的哪个页所占用。

分页和虚拟内存其实是两个东西，分页是人为的将地址空间分为固定大小的页，是为了更好的管理内存的分配，方便内存与外存的换入与换出，而虚拟内存则是为了解决程序的装载和重定位的问题。

我们假设只使用虚拟内存而不使用分页，实际上也是可以的，这种情况下的话（不考虑分段），对程序的分配就只能完整的分配，我们同样也需要设置类似页表的结构去进行不同程序与它们实际运行内存地址的映射。这样产生的问题就是内存利用率相对开启分页机制要低。

相反的，如果假设我们只使用分页机制不开启虚拟内存机制的话，那么就需要程序员在编程时确定程序的装入位置（甚至是每个页的位置，如果不连续装入的话），还需要确保不会与其它程序冲突，否则的话，如果不同的程序的某页使用的是同一个物理页框的话，操作系统根本没法确定这个物理页框到底分配给谁。

## LMA和VMA

LMA（Load Memory Address）是链接时计算的偏移地址，而VMA（VIrtual Memory Address）是程序运行时程序所在的地址，在没有开启分页机制时就是真实的物理地址，开启分页机制和虚拟内存后，VMA就是虚拟内存地址。

